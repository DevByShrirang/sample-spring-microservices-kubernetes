pipeline {
    agent any

    parameters {
        string(name: 'BRANCH_NAME', defaultValue: 'develop', description: 'Git branch to build')
    }

    environment {
        AWS_REGION        = 'us-east-2'
        ECR_REPO          = '442042505508.dkr.ecr.us-east-2.amazonaws.com'
        SONARQUBE_SERVER  = 'SonarQubeServer'
        AWS_CREDENTIALS   = 'aws-credentials'
        SONAR_PROJECT_KEY = 'microservices-dev'
        SONAR_PROJECT_NAME = 'microservices-dev'
        SONAR_PROJECT_VERSION = "1.0.${BUILD_NUMBER}"
    }

    stages {

        // üßπ CLEAN WORKSPACE
        stage('Clean Workspace') {
            steps {
                echo "üßΩ Cleaning Jenkins workspace before build starts..."
                cleanWs()
            }
        }

        // üì¶ CHECKOUT CODE
        stage('Checkout Code') {
            steps {
                echo "üì• Checking out code from branch: ${params.BRANCH_NAME}"
                git branch: "${params.BRANCH_NAME}", url: 'https://github.com/DevByShrirang/sample-spring-microservices-kubernetes.git'
            }
        }

        // üß± MAVEN BUILD (ROOT LEVEL)
        stage('Build All Microservices') {
            steps {
                echo "üèóÔ∏è Building all Maven modules from root..."
                // Ensure Jenkins runs Maven from the root directory
                dir("${WORKSPACE}") {
                    sh 'mvn -U clean package -DskipTests=false'
                }
            }
        }

        // üîç SONARQUBE
        stage('SonarQube Analysis') {
            steps {
                echo "üîç Running SonarQube Code Analysis..."
                withSonarQubeEnv("${SONARQUBE_SERVER}") {
                    sh """
                        mvn sonar:sonar \
                            -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                            -Dsonar.projectName=${SONAR_PROJECT_NAME} \
                            -Dsonar.projectVersion=${SONAR_PROJECT_VERSION} \
                            -Dsonar.host.url=$SONAR_HOST_URL \
                            -Dsonar.login=$SONAR_AUTH_TOKEN
                    """
                }
            }
        }

        // // üß† QUALITY GATE
        // stage('Quality Gate') {
        //     steps {
        //         timeout(time: 2, unit: 'MINUTES') {
        //             echo "üõ°Ô∏è Waiting for SonarQube Quality Gate result..."
        //             waitForQualityGate abortPipeline: true
        //         }
        //     }
        // }

        // üê≥ DOCKER BUILD AND PUSH FOR EACH SERVICE
        stage('Docker Build and Push for All Services') {
            steps {
                script {
                    def services = [
                        'admin-service',
                        'department-service',
                        'employee-service',
                        'gateway-service',
                        'organization-service'
                    ]

                    for (svc in services) {
                        def imageTag = "dev-${BUILD_NUMBER}"
                        def fullImageName = "${ECR_REPO}/${svc}:${imageTag}"

                        echo "üê≥ Building Docker image for ${svc}..."

                        sh """
                            docker build -t ${svc}:${imageTag} ${svc}/
                            aws ecr get-login-password --region ${AWS_REGION} \
                                | docker login --username AWS --password-stdin ${ECR_REPO}
                            docker tag ${svc}:${imageTag} ${fullImageName}
                            docker push ${fullImageName}
                        """
                    }
                }
            }
        }

        // üßπ POST-BUILD CLEANUP
        stage('Post-Build Cleanup') {
            steps {
                echo "üßπ Cleaning up local Docker images to save space..."
                sh 'docker system prune -f'
            }
        }
    }

    post {
        success {
            echo "‚úÖ Build pipeline completed successfully for branch: ${params.BRANCH_NAME}!"
        }
        failure {
            echo "‚ùå Build failed for branch: ${params.BRANCH_NAME}."
        }
        always {
            echo "üßΩ Final workspace cleanup after pipeline completion..."
            cleanWs()
        }
    }
}